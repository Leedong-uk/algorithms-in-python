#인접리스트에서 싸이클 찾기
#단순히 찾기만해선 안된다 어떤 정점이 싸이클에 들어가 있는지 아닌지도 판단해야한다 
#이게 어려움
#이미 방문한 정점을 또 방문하면 그 정점은 사이클의 시작이다 
#그러면 리턴해줄떄 사이클의 시작 정점을 리턴해준다 리턴후 도착한 곳의 정점이 사이클에 들어가는거고
# 그 정점도 시작정점을 리턴해준다 이렇게 계속 리턴하다가 시작정점에 다시 돌아오게 된다 


#n개의정점과 n개의 간선이 으로 되어있으면 사이클은 한개 뿐이다 


import sys
sys.setrecursionlimit(1000000)
from collections import deque
n = int(input())
a = [[] for _ in range(n+1)] #인접리스트 
check = [0] *(n) # 0 : 방문안함 , 1 : 방문함 , 2:cycle
dist = [0]*(n+1)

for _ in range(n) : 
    u , v = map(int,input().split())
    u -=1
    v -=1
    a[u].append(v)
    a[v].append(u)

def go(x,p) : 
    #-2 : 사이클을 찾았지만 , 이 정점은 사이클에 포함되지않음
    # -1 : 사이클을 못찾음
    # 0 ~ n-1 : 사이클을 찾았고 시작정점의 index를 리턴한다   

    if check[x] == 1 :  
        #★★★1번과정★★★
        #맨처음 이걸 조사한다 방문한곳을 다시 방문하면 사이클이라는 소리다 
        #그러면 현재점(x)가 사이클의 시작점이라는 소리다
        #그러면 지금부터 만나는 점들은 사이클 안에 있는 점들이고 
        #그런 점들을 만날떄마다 사이클안에 표시 되었다고 check[x] =2 만들고 시작점을 return한다
        #언제까지 ? res값이 사이클의 시작점과 같아질떄까지 
        return x     
    
    check[x] = 1 # 방문한점을 다시 방문안했다면 방문표시를한다

    for y in a[x] : 
        if y == p : #(같은곳을 계속 왔다 갔다 하는것을 방지한다 )
            continue
        res = go(y,x) 
        #★★★ 2번과정 ★★★
        #리턴하면 여기로 올것이다 그러면 res값에는 사이클의 시작값이 들어있다
        #정리하자면 x값: 현재정점값 , res값 : 사이클시작값  
        #그러면 우리가 할일은 x값이 res값과 같아지는 순간까지 계속 사이클의 시작값인 res를 return하는것이다


        if res == -2 : 
            #★★★ 3번과정 ★★★
            #-2가 발견됐다 그러면 지금 x값은 사이클에 포함되지않는다는점과 
            #사이클은 이미 발견되고 끝났다는 뜻이다 그런의미에서 -2를 다시 return해준다

            return -2
        
        if res >=0:
            #그 과정이 여기서 보여진다
            #우선 지금 현재값이 사이클안에 들어있다고 표시를 해준다
            # 그후 이과정을 계속 할지 말지 결정을 해야하기 위해서 x값(현재정점값)과 res값(사이클시작값)  을 비교한다
            #왜? 두 값이 같아지면 사이클이 끝난거기 떄문에 
            #두 값이 같지 않다면 res를 리턴한다
            #만일 두 값이 같아지면 이제부터 남아있는 것들 즉 리턴을 기다리는 애들은 사이클에 포함되지않고 
            # 잔챙이들이다 그러면 그걸 나타내기 위해서 -2를 리턴한다
            check[x] = 2 
            if x == res:
                return -2
            else :
                return res
    
    return -1 

go(0,-1)
#여기까지 했으면 사이클이 있고 사이클에 포함된 애들이 누군지까지 확인했다
#그럼이제 나머지애들이 이 사이클 까지의 거리를 알아야한다


#bfs를 이용한다 
#bfs를 이용해서 거리를 구하는 방법
#dis[i] : 시작점으로부터 i까지의 거리라고 정의한다
#예를들어 u 에서 v를 bfs로 방문했다 하면 시작점에서 v까지의 거리는
#dist[v] = dist[u]+1 이다 당연한거다 

q = deque()
dist = [-1]*n  #dist 를 -1로 초기화한다 이는 아직 방문하지 않았음을 의미한다 

for i in range(n) :  
    # 만일 check 가 2라면 사이클내에 있는 정점을 의미하고 그것들을 모두 q에넣어서 시작점으로 만들어준다
    # 즉 check가 2인 정점에서 출발해서 check값이 2 가 아닌 모든 정점까지의 거리를 계산할것이다
    if check[i] == 2 : 
        dist[i] = 0
        q.append(i)
    else:
        dist[i] = -1

while q: 
    x = q.popleft()
    for y in a[x] : 
        if dist[y] == -1 : 
            q.append(y)
            dist[y] = dist[x] +1

print(*dist, sep=' ')


    
