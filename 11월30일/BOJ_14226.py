#이번 문제에선 정점을 나누는 방법이다
#기존에 알고있었던 정점은 하나의 정점이 있으면 갈수있는 다른 정확한 정점이 존재한다
#이 문제에서는 다른건 괜찮은데 클립보드에 이모티콘이 얼마나 있는지에 따라서 갈수있는 정점이 달라진다 
#즉 어떤 정점으로든 갈수있고 정해진건 없다는 뜻이다 
#그래서 정점을 (s,c) 로 설정하고 s 는 screnn(화면)에 있는 이모티콘의 개수 ,c 는 clipboard 에 있는 이모티콘의 개수를 나타낸다
from collections import deque
n = int(input())
dist = [[-1]*(n+1) for _ in range(n+1)] # -1 : 방문 x , 0이상의정수 : 방문했을떄 걸리는 길이(시간)
#방문체크를 하는 이유는 기존 문제에서와 같이 bfs를 하면서 최소값을 찾기 위해서 
#내가 궁금한건 dist의 범위 였다 문제에서 볼떄 s 는 1000을 넘을수 없다 
#그래서 dist[1001][1001]로 만드는건 인정 근데 내가 의문점을 가진건 
#예를들어 n이 5이고 s(3,3)일떄 s(6,0) ->s(5,0) 이런 방식으로 경우에 따라선 최소값이 될수도 있지않나 ?
#그러면 범위가 틀린거 아닌가 ? 라고 생각을했지만 
#s(3,3)-> s(6,0) ->s(5,0) 이거랑 s(3,3)->s(2,3)->(5,0) 이건 시간적으로 똑같다 
#따라서 저렇게 범위를 잡아도 아무 상관 없다는 뜻

q= deque()
q.append((1,0))
dist[1][0] = 0

while q : 
    s,c = q.popleft()

    #복사 (s,c) -> (s,s)
    if dist[s][s] == -1 :
        dist[s][s] = dist[s][c] +1
        q.append((s,s))
    
    #붙여넣기 (s,c) -> (s+c,c)
    if s+c <=n and dist[s+c][c] == -1 : 
        dist[s+c][c] = dist[s][c] +1
        q.append((s+c,c))
    
    #삭제하기 (s,c) ->(s-1,c)
    if   s-1 >= 0 and dist[s-1][c] == -1 :
        dist[s-1][c] = dist[s][c]+1
        q.append((s-1,c))

ans = -1
for i in range(n+1) : 
    if dist[n][i] != -1 : 
        # 스크린에 해당 목표값만 있으면 클립보드에 어떤값이 있든지 상관없다
        #즉 해당 목표값 안에 있는 값들중 클립보드 수와 상관없이 시간이 작은걸 고르면 된다 
        if ans == -1 or ans > dist[n][i] : 
            ans = dist[n][i]
print(ans)

