n,m = map(int,input().split()) 

a = list(map(int,input().split()))

ans = 0

for i in range(1, (1<<n)): 
    # a라는 배열안에 숫자가 들어있고 각 숫자에는 인덱스가 부여 되어있음 
    # 그 인덱스를 가지고 돌려서 부분집합을 만들꺼임 
    #이떄 최대 부분집합의 수 즉 가장큰 비트마스크의 수는 1<<n-1 임으로 1<<n 까지 for문을 돌려주고
    #공집합은 포함하지 않는다고 하였기에 1부터 시작한다


    s = sum(a[k] for k in range(n) if (i & (1<<k)) > 0)
    #우선 여기서 k 역시 a의 index값들을 의미해 
    #여기서 지금 현재 만들어진 i라는 부분집합속에 어떤 index는 포함되어있을수도 있고 어떤 index는 포함 안되어있을수도 있음
    #그치 ? 그러면 어떤게 포함되어있는지를 확인해야지 왜 ? 그래야지 그 포함되어있는 놈을 통해서 진짜 값을 얻을수 있고
    #그 값을 통해서 문제가 원하는 s 가되는 부분집합의 수를 구할수 있기 떄문이야 
    #정리해보자면 이 문장에선 현재 만들어진 부분집합 i 속에 어떤 index k 값이 포함되어있는지 확인하고 
    #포함되어있으면 그 k인덱스의 value값을 가지고와서 값을 더해보는거야


    if m == s:
    #그리고 이렇게 더한 값이 우리가 찾고자하는 s값과 일치하면 그때 counter 값을 올려줘서 
    #결국 합이 s 가되는 모든 부분집합 의 갯수를 구해보는거임 
        ans += 1
print(ans)
